{"pages":[{"text":"I've been asked about this a few times already this month so I've decided to write down what I do to set up a new Mac for (mainly) Python Development. First, Install Dropbox and Sync Folders I keep my development folders on Dropbox as this gives me some degree of machine independence. More recently, I've also started to keep my dotfiles on Dropbox and use MackUp to handle the syncing of the dotfiles between machines. MackUp is a pretty straight forward symbolic linking system and it basically does what I would have done if I had rolled my own utility. Be aware though that Mackup's default behavior is to put your .ssh folder and its contents on Dropbox. If you don't like this behavior then it must be overridden manually. I always start by installing Dropbox and syncing my Development folders, as I typically have lots of stuff of on Dropbox so it takes a while to sync everything. You may want to consider using the Selective Sync feature to control the syncing process. Upgrade your Terminal: Install Iterm 2 You're going to need a decent terminal application for your command line work. While the bundled OS X terminal application has gotten a lot better with recent releases of the OS X it still has a way to go to match Item2 . Some of the many features of Iterm are listed here . So use Item2 as your terminal. Install XCode: You'll need at least the Command Line Tools You need to install either the full version Xcode or at least to the Command line tools. These can be actually installed from the command line by entering the following in you terminal window xcode-select --install You will then be prompted to either install the full Xcode or just the command line developer tools, with the latter being the default. Once you've installed one or the other, you can proceed to installing Homebrew . Install Homebrew Homebrew is a package management system that simplifies the installation of libraries, tools and utilities you typically need for development. Homebrew is actually a Ruby application and to install it just visit the Homebrew homepage copy and paste the code listed under Install Homebrew into your terminal. The install snippet changes occasionally and it is currently ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\" But be remember to visit Homebrew homepage to get the correct code snippet. Next run brew doctor and then brew update Then to install some packages to make sure everything works brew install ssh-copy-id git mercurial mackup Set Up Your Shell Environment I'm a convert to Zsh or really oh-my-zsh . However, the same would apply if you used bash or any other shell If you are using the bash shell then edit your bash_profile vi ~/.bash_profile or for oh-my-zsh vi ~/.zshrc Add the following lines # set the architecture flags export ARCHFLAGS = \"-arch x86_64\" # Ensure that local bin is first in path export PATH = /usr/local/bin: $PATH These changes will take effect the next time you restart the shell. Rather, than restarting your shell simply type the following in the terminal. source ~/.zshrc or if you are using bash source ~/.bash_profile Use the Homebrew Python Apple has always bundled Python along with its OS releases. However, we advise you not to use the bundled Python for development and instead to install Python via homebrew . We prefer the brew Python for a number of reasons including : Apple makes changes to its bundled Python and this can gives rise to bugs and incompatibilities. If you use the bundled Python you can upgrade to the latest and the greatest version of OS X you may find that your packages, virtualenvs etc. may all need to be reinstalled and recreated As new versions of Python are released, the bundled Python becomes more and more out-of-date. Homebrew will allow you the upgrade to the most recent versions of Python (2 or 3). Homebrew allows you to easily play around with Python 3 as it comes with pip3 for installing packages To install Python with homebrew enter brew install python And optionally install Python 3 brew install python3 Install VirtualEnv and VirtualEnv Wrapper A Virtual Environment , is an isolated working copy of Python and installed packages that allows you to work on a specific project without the worry of affecting other projects. The virtualenv package allows you to create virtual environments while the virtualenvwrapper package provides a framework for organizing your virtual environments. Install them using pip pip install virtualenv pip install virtualenvwrapper Next, create a directory to store your virtual environments mkdir -p ~/virtualenvs We'll then edit the ~/.zshrc file or ( .bashrc or .bash_profile ) vim ~/.zshrc and add the following lines to it # cache pip-installed packages to avoid re-downloading export PIP_DOWNLOAD_CACHE = $HOME /.pip/cache export WORKON_HOME = $HOME /virtualenvs source /usr/local/bin/virtualenvwrapper.sh Restart your terminal or type the following in the terminal window source ~/.zshrc or source ~/.bash_profile Next, we want to test out your setup by building a C based python package. Start by installing some shared libraries via brew brew install libjpeg lcms libtiff libpng freetype Next create a test virtualenv and install the C based python package in this case Pillow which needs to be built against the shared libraries that you just installed using brew mkvirtalenv test -env pip install Pillow Everything is fine if you get a post install message like similar to the one shown below PIL SETUP SUMMARY -------------------------------------------------------------------- version Pillow 2.4.0 platform darwin 2.7.6 (default, Apr 9 2014, 11:48:52) [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] -------------------------------------------------------------------- --- TKINTER support available --- JPEG support available *** OPENJPEG (JPEG2000) support not available --- ZLIB (PNG/ZIP) support available --- LIBTIFF support available --- FREETYPE2 support available *** LITTLECMS2 support not available *** WEBP support not available *** WEBPMUX support not available Extras PostgreSQL You can of course use homebrew to install PostgreSQL . However, I've found that that it takes a lot of manual tweaking to get all the procedural languages ( PL/pgSQL , PL/Python , PLV8 etc.) as well as extensions like PostGIS , hstore etc. working. In contrast, Postgresapp pretty much works out of the box and gives you stable, up-to-date version PostgreSQL/PostGIS pretty much configured for any kind of development that you are likely to do. Postgresapp also comes with the full set of PostgeSQL/PostGIS command line tools however, you need to add the bin directory to your path. As before, depending on you shell of choice add the following to your .zshrc , .bash_profile or .bashrc PATH = \"/usr/local/bin:/Applications/Postgres.app/Contents/MacOS/bin:$PATH\" Restart you terminal app or type the following in the terminal window source ~/.zshrc or if you use another shell example bash source ~/.bash_profile Finally, test out your setup by typing createdb test -db #create a new database psql test -db dropdb test -db Install a GUI Version Control Client While we can use Homebrew to install source control tools (i.e git and or mercurical ) many new developers, or those coming from backgrounds in design can sometimes feel a bit intimidated by using git and mecurical from the command line. So to help them get over the hump we usually recommend they also install a free git and mercurial GUI client such as SourceTree . Python Data Tools Python is becomming more and more popular for statistics, data analysis and data science tasks. In particular you may be interested in in developing solutions using the SciPy stack and using tools like IPython , Matplotlib , Pandas , scikit-learn , etc. The usual recommendation is to use a binary distribution such as Anaconda or Enthought Canopy , but as a developer you will want/need to use the source distribution. Start by adding these lines to your .zshrc or .bash_profile . export CFLAGS = \"-arch i386 -arch x86_64\" export FFLAGS = \"-m32 -m64\" export LDFLAGS = \"-Wall -undefined dynamic_lookup -bundle -arch i386 -arch x86_64\" export CC = gcc export CXX = \"g++ -arch i386 -arch x86_64\" This should take care of problems you can sometimes encounter in building some numpy and scipy extensions. Next install some of the perquisites libraries and applications using homebrew. brew install gfortran pkg-config zeromq readline Then install numpy and scipy using pip. We will also install nose so we can run the test suite. pip install numpy pip install scipy pip install nose Note, I'm installing these packages directly to the system site packages i.e. in /usr/local/lib/python-2.7/site-packages as opposed to a particular virtualenv as I often use pydata packages for ad-hoc hacking and experimentation. You can run the test suite by starting Python and running import scipy import numpy numpy . test () scipy . test () Almost all the numpy test should pass but interestingly there will be quite a few known failures with scipy . This should not be a problem Next install pandas pip install pandas Then we can install IPython (including support for the IPython notebook) , as well as matplotlib and the ipython sql extension which allows you to to connect to a database and then issue SQL commands within IPython or IPython Notebook . pip install jinga2 pip install ipython pyzmq tornado pygments pip install matplotlib pip install pycopg2 pip install ipython-sql Check that everything is setup properly by launching the IPython notebook with matplotlib integration. ipython notebook --pylab = inline Here is a sample session from notebook I created Start by importing pandas and load the sql magics import pandas as pd % load_ext sql Connect to a PosgreSQL database with data from the Trinidad and Tobago stock exchange and execute sql %% sql postgresql : // localhost / mass - db select sd . dateix , s . ticker , sd . close_price , sd . volume from markets_symboldata sd , markets_symbol s where s . id = sd . symbol_id order by sd . dateix desc limit 10 ; 10 rows affected. dateix ticker close_price volume 2014-01-27 00:00:00-04:00 NCBJ 1.0 1901965 2014-01-27 00:00:00-04:00 RBL 116.52 8109 2014-01-27 00:00:00-04:00 GHL 14.0 4294 2014-01-27 00:00:00-04:00 JMMB 0.49 18500 2014-01-27 00:00:00-04:00 NEL 18.25 1348 2014-01-27 00:00:00-04:00 NFM 0.96 15500 2014-01-27 00:00:00-04:00 AHL 11.0 1000 2014-01-27 00:00:00-04:00 FIRST 42.4 3891 2014-01-27 00:00:00-04:00 CIF 22.75 3210 2014-01-27 00:00:00-04:00 SBTT 73.12 624 Execute another query using the connection established above to retrieve the last 100 days of data for GHL. Store the result in a variable called results result = % sql select sd . dateix , s . ticker , sd . close_price , sd . volume from markets_symboldata sd , markets_symbol s where s . id = sd . symbol_id and s . ticker = 'GHL' order by sd . dateix desc limit 100 100 rows affected. Because pandas is available we can use the DataFrame method to create a DataFrame from the resultset df = result . DataFrame () df . info () <class 'pandas.core.frame.DataFrame'> Int64Index: 100 entries, 0 to 99 Data columns (total 4 columns): dateix 100 non-null object ticker 100 non-null object close_price 100 non-null float64 volume 100 non-null int64 dtypes: float64(1), int64(1), object(2) Convert the df to a time series by setting the index to the dateix df . set_index ( 'dateix' , inplace = True ) Statistical summary of the closing price and volume df . describe () close_price volume count 100.000000 100.000000 mean 14.806300 11008.670000 std 0.902168 16633.468579 min 13.500000 21.000000 25% 14.000000 1718.750000 50% 14.975000 4447.000000 75% 15.600000 12569.250000 max 16.450000 82430.000000 8 rows \u00d7 2 columns Use matplotlib to plot the closing price df [ 'close_price' ] . plot () <matplotlib.axes.AxesSubplot at 0x11650bcd0>","tags":"python","loc":"http://blog.chrisdev.com/setting-up-your-python-development-environment-on-osx-mavericks.html","title":"How I Setup my Macs for Python Development"},{"text":"I was really looking forward to reviewing this book as I'm a big fan of Zurb Foundation as I think that it is by far the best responsive framework out there. Indeed, at work here at ChrisDev , we use Foundation for all our web based projects. The book is supposed to aimed at web architects, designers, and builders who were already familiar with the basics principles of responsive design and is divided up into four chapters. I found that Chapter 1: Getting The Most from the Grid System was the most useful of the lot. The author discussed in some detail his approach to dealing with a number of practical layout issues including: nesting rows in columns; understanding and customizing column gutters; maintaining row and page width; mobile first design (or what the author calls designing from small to to large); rearranging columns and so on. While I found that this chapter hit all the basics I felt more emphasis should have been placed on the implications of mobile first design as this has always been Foundation's big selling point over rivals such as Twitter BootStrap . Also, it was strange that there was no mention of some of the great resources provided by Zurb such as the Foundation 4 Templates which provide a number of canned layouts for various kinds of sites (blogs, marketing product page etc.) that can be a great starting point for customizing layout. I was a little disappointed in the next two chapters which covered the CSS and JavaScript components provided with Foundation. These seemed a little cursory and there was little that went beyond the online documentation . Of course Foundation comes with more than twenty CSS components about twelve JavaScript Plugins so it would have been unrealistic to expect a comprehensive treatment of all these components, but maybe the author could have singled out the more popular component such as Orbit for more comprehensive treatment. The final chapter covered Sass . I felt that there was a lot of good material here and readers unfamiliar with Sass would find it quite enlightening. I particularly liked the sections entitled Customizing with Variables and Understanding functions and mixins . However, I felt that more emphasis should have been placed on this topic given that Sass has become the most efficient way to customize and style layout, components and plugins. I would have preferred if Sass could have been introduced very early on (probably as Chapter 2) and the subsequent chapters covering CSS and JavaScript components each contain a section on how to customize one or more of the components or plugins with Sass. Overall, I would have to give this book a 3 out of 5 stars since it covers the basics and provides a good supplement for the online documentation . However, I feel that for more experienced designers, architects and builders the book will prove to be a bit of a disappointment. Aside from Chapter 1 , it provides little in the way of a practical approach or even some guidelines for building real world responsive sites with Foundation. This is important in the context of a rapidly evolving framework like Zurb Foundation, where we are we are reviewing a book about version 4 while Foundation 5 has been out since November 21, 2013.","tags":"Zurb Foundation","loc":"http://blog.chrisdev.com/book-review-getting-started-with-zurb-foundation.html","title":"Book Review: Getting Started with Zurb Foundation 4 by Andrew D. Patterson"},{"text":"I've started experimenting with a static blog in the hope that this will encourage me to post on a more frequently . I've decided to go with pelican as it's written in python, set up and has good documentation and I'm using github pages for hosting. Getting Started First, I created a virtualenv for the project and installed the main requirements. mkvirtualenv chrisdev-blog pip install pelican I then used pelican-quickstart to create the skeleton of my project pelican-quickstart Since I was going to host on Github I felt that I did not need the generated Makefile, and all the other helper scripts. Instead, I created a settings file that initially looked like this: AUTHOR = 'Christopher Clarke' DEFAULT_DATE_FORMAT = '%A, %B %d , %Y' DISQUS_SITENAME = 'chrisdev' GITHUB_URL = 'https://github.com/chrisdev/chrisdev-blog' GOOGLE_ANALYTICS = '' SITEURL = 'http://blog.chrisdev.com' FEED_DOMAIN = SITEURL SITENAME = 'TheChrisDev Blog' SOCIAL = (( 'twitter' , 'http://twitter.com/realchrisdev' ), ( 'github' , 'https://github.com/chrisdev' ), ( 'facebook' , 'http://www.facebook.com/chrisdevtt' ),) TAG_FEED_ATOM = 'feeds/ %s .atom.xml' TIMEZONE = \"America/Port_of_Spain\" TWITTER_USERNAME = 'realchrisdev' To generate the site I created a test rst file in the content directory and ran the following: pelican content -s settings.py -o . To view the generated site just open the index file in your browser or if you are on a Mac open index.html Theming The Blog By default pelican will theme your site using notmyidea . But I wanted to use a theme based on Zurb Foundation 4 . Fortunately, the official pelican-themes repository already contained a Foundation 4 theme called tuxlite_zf . This is a minimalist theme with a main column and a right sidebar. That I felt would provide a good starting point for a custom theme. To install the pelican-themes we simply cloned the repository to our local machine. git clone https://github.com/getpelican/pelican-themes ~/Development/pelican-themes We then copied the tuxlite_zf theme folder to a new folder chrisdev_zf so that we could customize it. Next, we edited settings.py file to include this line: THEME = \"../pelican-themes/chrisdev_zf\" Finall, we regenerated the site as before to confirm that tuxlite_zf was indeed generating a Foundation 4 site. Customization with SASS and Compass The best way to customize a Foundation 4 site is to use Sass and Compass This normally means that ruby needs to be installed on your system. If you are on a Mac then you are in luck since a fairly recent version of ruby ships with Mountain Lion . Update your ruby installation and install Foundation 4 and all the necessary dependencies i.e. Sass and Compass . sudo gem update --system sudo gem install compass sudo gem install zurb-foundation Next create a project for your custom theme. compass create custom-foundation4 -r zurb-foundation --using foundation You can view index.html in your browser confirm that your project is a standard Foundation 4 site. Next, you will want to start by making changes to the Scsss files and use with compass to generate css output. The Foundation folks have made this easy for us as you can modify almost any Foundation CSS component by editing _settings.scss file which is located in the sass folder of the custom-foundation project. For example, to change the colors of the Top-nav we made the following changes to _settings.scss $topbar - dropdown - bg : #3498db; $topbar - dropdown - toggle - alpha : 0 . 1 ; $dropdown - label - color : #fff; Next run compass compile You can also set compass in watch mode so that it will watch for saves and compile each time you save an Scss file. Additionally, you can also configure compass to generate compressed code by editing the 'config.rb' and uncommenting output_style = :compressed # or :compressed expanded or :nested or Once you are satisfied, you can copy app.css as foundation.css to your custom pelican-theme's static directory. Once you have gained more experience with compass/sass you will want to target particular CSS components to modify them instead of regenerating the entire foundation.css every time you make a few changes to components. To achieve this we simply created a new scss called style.scss and imported just those components that we wished to modify. So as in the example above where we just wanted to change the top-nav colors we just add the following lines to style.sccs $topbar - dropdown - bg : #3498db; $topbar - dropdown - toggle - alpha : 0 . 1 ; $dropdown - label - color : #fff; @import \"foundation/components/grid\" ; @import \"foundation/components/top-bar\" ; Note, you need to define the new colors etc. before you import the foundation components. As before, compile the style.css and copy this to the static directory of your pelican theme. Deployment On Github I started by creating a repository on my github called chrisdev.github.com . The use of my github account name as the first part of the repository name was necessary to indicate that this was a special repository for serving User or Organization html pages from the master branch of a repository. The site would be viewable at http://chrisdev.github.io . Next in the the directory where I created the pelican blog I ran the followig git init git add . git commit -m \"initial commit\" git remote add origin git@github.com:chrisdev/chrisdev.github.com.git To update the site I just have to push to the origin git push -u origin master I also set up a custom domain for the blog at http://blog.chrisdev.com by simply setting up a CNAME record in my DNS to set blog.chrisdev.com as an alias for chrisdev.github.com . I also had to add a file to the github repository called CNAME which contained a sigle line with the alias i.e blog.chrisdev.com .","tags":"pelican","loc":"http://blog.chrisdev.com/welcome.html","title":"Welcome To My Blog"}]}